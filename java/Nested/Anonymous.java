package Nested;

public class Anonymous {
    /*
    익명 자식 객체

    익명 자식 객체는 클래스를 상속해야만 생성할 수 있다.
    그러나 자식 클래스를 일회성으로 사용할 경우 자식 클래스를 만드는 것보다 익명 자식 객체를 생성해서 사용하는 것이 더 좋다
    일회성으로 사용하는 경우는 필드의 초기값, 로컬 변수의 초기값, 매개값등이 있다. 따라서 익명 자식 객체는 이런 곳에 주로 사용된다.
    익명 자식 객체 -> new 부모클래스() { ... }
    부모클래스() 부모 생성자를 호출하는 코드, {...} 는 자식 클래스의 필드나 메서드 선언, 부모 클래스의 메서드를 오버라이딩한 메서드를 작성한다.
    new 연산자로 중괄호의 기능을 가진 익명 자식 객체를 생성한다. 일반 객체와 차이점은 생성자가 없기 때문에 필드와 메서드를 선언할 때 필드의 초기값, 로컬 변수의 초기값을 반드시 대입해야 한다.
     */

    // 필드의 초기값에 사용된 익명 자식 객체
    Person field = new Person() {
        // 익명 자식 객체 메서드 선언
        void work() {
            System.out.println("출근합니다.");
        }
        // 부모 클래스의 메서드를 오버라이딩
        @Override
        public void wake() {
            System.out.println("6시에 일어납니다.");
            work();
        }
    };

    // 로컬 변수 초기값에 사용된 익명 자식 객체
    void method1() {
        Person localVar = new Person() {
            /*
            익명 자식 객체 메서드 선언

            익명 자식 객체에서 선언된 필드와 메서드를 외부에서 접근할 수 없다.
            이유는 익명 자식 객체가 부모 타입의 변수에 저장되면 부모 타입으로 자동 타입 변환이 되어 부모 클래스에 선언된 것만 사용할 수 있기 때문이다.
            익명 자식 객체 내부에서는 얼마든지 사용 가능하다.
             */
            void walk() {
                System.out.println("산책합니다.");
            }

            // 부모 클래스의 메서드를 오버라이딩
            @Override
            public void wake() {
                System.out.println("7시에 일어납니다.");
                walk();
            }
        };

        localVar.wake();
    }

    // 매개 변수가 부모 타입이라서 매개값으로 익명 자식 객체가 들어오면 부모 타입으로 자동 타입 변환이 되며
    // 익명 자식 객체의 wake() 메서드에 따라서 다양한 결과를 얻을 수 있다. -> 매개변수의 다형성
    void method2(Person person) {
        person.wake();
    }
}
