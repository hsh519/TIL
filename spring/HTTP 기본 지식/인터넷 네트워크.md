# 인터넷 네트워크

컴퓨터는 인터넷 망을 통해서 통신한다. 복잡하게 구성되있는 인터넷 망을 통해 어떻게 통신하는 것일까? 바로 IP를 이용한다

**IP**

- 컴퓨터당 하나씩 가지고 있다
- 패킷이라는 통신 단위로 데이터를 전달
- IP 패킷에는 출발 IP, 도착 IP, 기타 정보등이 있으며 전송 데이터를 감싼다

인터넷 망에 있는 노드가 IP 패킷을 받으면 도착 IP로 갈 수 있는 다른 노드에게 전달해준다. 이렇게 계속 전달전달해주면 도착 IP에 해당하는 컴퓨터까지 갈 수 있고 패킷을 받은 컴퓨터는 보낸 컴퓨터에게 잘 받았다는 패킷을 보내준다.

IP 한계

- 비연결성 : 상대 컴퓨터의 상태와 상관없이 일단 보내기
- 비신뢰성 : 패킷 순서 보장X, 중간에 패킷이 사라져도 신경 안씀
- 프로그램 구분 : 같은 컴퓨터에 다른 두 애플리케이션이 패킷을 전송하면 어떻게 구분하지..

**TCP/UDP**

그래서 IP 위에 TCP/UDP를 올리면서 IP한계를 해결해준다

TCP

- TCP 패킷에는 출발 PORT, 도착 PORT, 검증 정보, 순서, 전송 제어등이 있으며 IP 패킷보다 먼저 전송 데이터를 감싼다
- 연결 지향 : TCP 3way handshake
- 데이터 전달 보증
- 데이터 순서 보장
- 신뢰할 수 있는 프로토콜

TCP는 데이터를 전송하기 전에 TCP 3way handshake(SYN, SYN+ACK, ACK)를 통해서 상대 컴퓨터의 상태를 확인한다. 이 과정이 성공하면 가상 연결을 한 뒤 패킷을 전송한다. 이때 패킷이 순서대로 도착하지 않으면 수신측 컴퓨터가 어떤 패킷부터 다시 보내라고 알려주며, 수신측 컴퓨터의 잘 받았다는 메세지가 없다면 데이터가 중간에 사라졌기 때문에 데이터 전달 또한 보증한다. 따라서 신뢰할 수 있지만 확인 과정이 있어 속도가 느리다

UDP

- IP와 다를게 없다
- PORT 와 체크섬만 추가
- 추가된 것이 거의 없어 속도가 빠르다
- 애플리케이션에서 추가 작업을 통해 커스텀 가능

**PORT**

IP 한계중 프로그램 구분은 PORT로 해결한다. IP는 아파트라면 PORT는 호수라고 생각하면 편하다. 같은 컴퓨터에 다른 두 애플리케이션에서 보낸 패킷이라도 TCP 패킷에 PORT를 확인하면 구분할 수 있다. 0 ~ 65535 PORT를 사용할 수 있지만 0 ~ 1023 PORT는 일반적으로 잘 알려진 PORT라 가급적 사용하지 않는게 좋다.

**DNS**

이제 여러 컴퓨터와 통신할 수 있게 됬지만 통신할 때마다 IP를 외우고 사용하기에는 쉽지 않을 뿐더러 IP가 바뀌면 그 컴퓨터와 통신이 끊기게 된다. 그래서 도메인명을 IP로 바꿔주는 DNS 서버를 사용한다. 우리가 www.~~와 같이 도메인명을 치게 되면 DNS 서버가 도메인명에 맞는 IP를 반환해주고 우리는 그 IP로 접근하면 된다.

**URI**

URI는 특정 리소스를 식별하는 통합 자원 식별자다. 리소스의 위치나 이름으로 식별하는데 리소스의 위치로 식별하면 URL, 리소스의 이름으로 식별하면 URN이다. 즉, URI 안에는 URL과 URN이 있다. 리소스의 위치는 변할 수 있지만 이름은 변할 수 없다. 그래서 이름으로 사용하면 좋을거라 생각하지만 사실 URN 만으로 실제 리소스를 찾을 수 있는 방법이 보편화되지 않았기 때문에 URL을 사용한다. 어짜피 URN은 거의 안쓰이기 때문에 URI와 URL을 같은 의미로 생각해도 된다.

URL

- URL 전체 문법 : scheme://[userinfo@]host[:port][/path][?query][#fragment]
- scheme는 주로 프로토콜을 사용. 프로토콜은 어떤 방식으로 리소스에 접근할 것인지 정한 규칙
- userinfo는 URL에 사용자정보를 포함해서 인증. 거의 사용하지 않는다
- host는 도메인명 혹은 IP를 입력
- port는 접속 포트 입력. http와 https는 생략시 80, 443 포트에 접속
- path는 리소스 경로를 입력. 보통 계층적 구조로 짠다
- query는 웹 서버에 제공하는 파라미터를 입력. 쿼리 문장 자체가 문자열 형태로 넘겨진다. key=value 형태며 ?로 시작하고 여러 key-value를 넘길때 &로 연결. 쿼리 파라미터, 쿼리 스트링으로 불린다
- fragment는 서버의 전송하는 정보는 아니며 html 내부 북마크에 사용

**웹 브라우저의 요청 흐름**

프로토콜 4계층은 위에서부터 애플리케이션 계층, 전송 계층, 인터넷 계층, 네트워크 인터페이스 계층이며 전송할 때는 위에서 아래로, 받을 때는 아래서 위로 진행된다. 우리가 https://www.google.com/search?q=hello&hl=ko URL을 요청할 때 어떻게 웹 브라우저가 페이지를 띄워주는지 알아보겠다.

1. 웹 브라우저가 DNS 서버에 google에 맞는 IP를 받고 해당 URL의 포트를 알아낸 뒤 http 요청 메세지를 생성한다. (애플리케이션 계층)
2. socket 라이브러리를 통해 TCP 3way handshake로 상대 컴퓨터의 상태를 확인한 후 가상 연결을 하고 http 요청 메세지를 전송 계층으로 보낸다. (애플리케이션 계층)
3. TCP 패킷으로 http 요청 메세지를 감싼다.(이때 포트 사용) 이후 인터넷 계층으로 보낸다. (전송 계층)
4. IP 패킷으로 TCP 패킷을 감싼다.(이때 IP 사용) 이후 네트워크 인터페이스 계층으로 보낸다. (인터넷 계층)
5. 네트워크 인터페이스 계층에서 필요한 정보를 담은 뒤 IP 패킷을 감싸서 상대 컴퓨터에게 보낸다. (네트워크 계층)
6. 상대 컴퓨터가 받으면 네트워크 계층부터 애플리케이션 계층까지 올라가면서 패킷을 하나씩 벗겨 http 요청 메세지를 확인한다.
7. http 요청 메세지에 맞는 http 응답 메세지를 만들어 1~5번 과정을 거쳐(TCP 3way handshake 과정 생략) 요청한 컴퓨터에게 보낸다.
8. 요청한 컴퓨터가 받으면 6번의 과정을 거쳐 http 응답 메세지를 확인하고 웹 브라우저가 랜더링해서 우리에게 화면을 띄워준다.
